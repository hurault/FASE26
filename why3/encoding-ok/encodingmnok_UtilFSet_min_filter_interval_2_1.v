(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require set.Fset.
Require set.FsetInt.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a), (0%Z <= (set.Fset.cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a),
  set.Fset.is_empty s <-> ((set.Fset.cardinal s) = 0%Z).

Axiom cardinal_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set.Fset.fset a),
  ((set.Fset.cardinal (set.Fset.map f s)) <= (set.Fset.cardinal s))%Z.

Axiom add_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (e:a), set.Fset.mem e s ->
  (s = (set.Fset.add e s)).

Axiom add_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set.Fset.fset a) (e:a), ~ set.Fset.mem e s ->
  ((set.Fset.map f (set.Fset.add e s)) =
   (set.Fset.add (f e) (set.Fset.map f s))).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set.Fset.fset a),
  (set.Fset.mem x s ->
   ((set.Fset.cardinal (set.Fset.add x s)) = (set.Fset.cardinal s))) /\
  (~ set.Fset.mem x s ->
   ((set.Fset.cardinal (set.Fset.add x s)) = ((set.Fset.cardinal s) + 1%Z)%Z)).

Axiom interval_def :
  forall (l:Numbers.BinNums.Z) (r:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  set.Fset.mem x (set.FsetInt.interval l r) <-> (l <= x)%Z /\ (x < r)%Z.

Axiom min_elt_def :
  forall (s:set.Fset.fset Numbers.BinNums.Z), ~ set.Fset.is_empty s ->
  set.Fset.mem (set.FsetInt.min_elt s) s /\
  (forall (x:Numbers.BinNums.Z), set.Fset.mem x s ->
   ((set.FsetInt.min_elt s) <= x)%Z).

Axiom cardinal_interval :
  forall (l:Numbers.BinNums.Z) (r:Numbers.BinNums.Z),
  ((l <= r)%Z ->
   ((set.Fset.cardinal (set.FsetInt.interval l r)) = (r - l)%Z)) /\
  (~ (l <= r)%Z -> ((set.Fset.cardinal (set.FsetInt.interval l r)) = 0%Z)).

Axiom filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (p:a -> Init.Datatypes.bool) (x:a),
  set.Fset.mem x (set.Fset.filter s p) <->
  set.Fset.mem x s /\ ((p x) = Init.Datatypes.true).

Axiom min_filter_interval_1 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  (a <=
   (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)))%Z /\
  ((set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)) <
   b)%Z.

(* Why3 goal *)
Theorem min_filter_interval_2 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  ((p (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p))) =
   Init.Datatypes.true).
(* Why3 intros a b p (i,((h1,h2),h3)). *)
Proof.
intros a b p not_all.
generalize (min_elt_def (Fset.filter (FsetInt.interval a b) p)).
intro.
destruct H.
generalize (cardinal_empty ((Fset.filter (FsetInt.interval a b) p))).
intro.
destruct H.
unfold not.
intro.
generalize (H H1).
intro.
(* contradiction between the empty set and that they are not all false *)
destruct not_all.
unfold Fset.is_empty in H1.
generalize (filter_def (FsetInt.interval a b) p x).
intro.
generalize (interval_def a b x).
intro.
generalize (H1 x).
tauto.
generalize (filter_def (FsetInt.interval a b) p).
intro.
generalize (H1 (FsetInt.min_elt (Fset.filter (FsetInt.interval a b) p))).
intro.
destruct H2.
generalize (H2 H).
intro.
destruct H4.
exact H5.

Qed.

