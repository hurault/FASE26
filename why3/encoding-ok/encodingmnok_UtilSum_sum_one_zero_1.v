(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  infix_eqeq s1 s2 <->
  ((length s1) = (length s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), infix_eqeq s1 s2 -> (s1 = s2).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> ((length (create len f)) = len).

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < len)%Z -> ((get (create len f) i) = (f i)).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result s i v j) = v)) /\
  (~ (j = i) -> ((result s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result s i v))).

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((length (set s i v)) = (length s)).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (set s i v) i) = v).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> forall (j:Numbers.BinNums.Z),
  ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
  ((get (set s i v) j) = (get s j)).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((length (singleton v)) = 1%Z).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((get (singleton v) 0%Z) = v).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result1 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result1 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result1 x s).

Axiom cons'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((length (cons x s)) = (1%Z + (length s))%Z).

Axiom cons'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((get (cons x s) 0%Z) = x).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z < i)%Z /\ (i <= (length s))%Z ->
  ((get (cons x s) i) = (get s (i - 1%Z)%Z)).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result2 s x i) = x)) /\
  (~ (i = (length s)) -> ((result2 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result2 s x).

Axiom snoc'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((length (snoc s x)) = (1%Z + (length s))%Z).

Axiom snoc'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((get (snoc s x) (length s)) = x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (snoc s x) i) = (get s i)).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
  ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z)).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result3 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result3 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result3 s1 s2 l).

Axiom infix_plpl'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z).

Axiom infix_plpl'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s1))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s1 i)).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z)).

Parameter sum:
  (Numbers.BinNums.Z -> Numbers.BinNums.Z) -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom sum'def :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  ((b <= a)%Z -> ((sum f a b) = 0%Z)) /\
  (~ (b <= a)%Z ->
   ((sum f a b) = ((sum f a (b - 1%Z)%Z) + (f (b - 1%Z)%Z))%Z)).

Axiom sum_left :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (a < b)%Z -> ((sum f a b) = ((f a) + (sum f (a + 1%Z)%Z b))%Z).

Axiom sum_ext :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> ((f i) = (g i))) ->
  ((sum f a b) = (sum g a b)).

Axiom sum_le :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z ->
   ((f i) <= (g i))%Z) ->
  ((sum f a b) <= (sum g a b))%Z.

Axiom sum_zero :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> ((f i) = 0%Z)) ->
  ((sum f a b) = 0%Z).

Axiom sum_nonneg :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> (0%Z <= (f i))%Z) ->
  (0%Z <= (sum f a b))%Z.

Axiom sum_decomp :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  (a <= b)%Z /\ (b <= c)%Z -> ((sum f a c) = ((sum f a b) + (sum f b c))%Z).

Axiom shift_left :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((b - a)%Z = (d - c)%Z) ->
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z ->
   ((f i) = (g ((c + i)%Z - a)%Z))) ->
  ((sum f a b) = (sum g c d)).

(* Why3 assumption *)
Definition sum1 (s:seq Numbers.BinNums.Z) : Numbers.BinNums.Z :=
  sum (fun (i:Numbers.BinNums.Z) => get s i) 0%Z (length s).

Axiom sum_snoc :
  forall (s:seq Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((sum1 (snoc s x)) = ((sum1 s) + x)%Z).

Axiom sum_tail :
  forall (s:seq Numbers.BinNums.Z), (1%Z <= (length s))%Z ->
  ((sum1 s) = ((get s 0%Z) + (sum1 (mixfix_lb_dtdtrb s 1%Z)))%Z).

Axiom sum_tail_tail :
  forall (s:seq Numbers.BinNums.Z), (2%Z <= (length s))%Z ->
  ((sum1 s) =
   (((get s 0%Z) + (get s 1%Z))%Z + (sum1 (mixfix_lb_dtdtrb s 2%Z)))%Z).

Axiom sum_ge_elt :
  forall (s:seq Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s))%Z ->
   (0%Z <= (get s i))%Z) ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((get s i) <= (sum1 s))%Z.

Axiom sum_one :
  forall (k:Numbers.BinNums.Z),
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z), (0%Z <= k)%Z ->
  (forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < k)%Z -> ((f j) = 1%Z)) ->
  ((sum f 0%Z k) = k).

Require Import Lia.

(* Why3 goal *)
Theorem sum_one_zero :
  forall (k:Numbers.BinNums.Z),
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z), (0%Z <= k)%Z ->
  (forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < k)%Z ->
   ((f j) = 1%Z) \/ ((f j) = 0%Z)) ->
  ((sum f 0%Z k) <= k)%Z.
(* Why3 intros k f h1 h2. *)
Proof.
intros k f h1 h2.
remember (Z.to_nat k) as m eqn:Heqm.
(* Induction on m *)
revert k h1 h2 Heqm.
induction m.
intros.
(* m=0 *)
assert (k=0%Z) by lia.
rewrite H.
generalize (sum'def f 0 0).
intro.
destruct H0.
lia.
(* inductive case  *)
intros.
generalize (sum'def f 0 k).
intro.
destruct H.
assert (~ (k <= 0)%Z) by lia.
rewrite (H0 H1).
cut ((sum f 0 (k - 1) <= k-1)%Z).
cut ((f (k - 1) <= 1)%Z).
lia.
(* ((f (k - 1) <= 1)%Z) *)
generalize (h2 ((k-1)%Z)).
intro.
assert ((0 <= k - 1 < k)%Z) by lia.
lia.
(* ((sum f 0 (k - 1) <= k-1)%Z) *)
apply IHm.
lia.
intros.
apply h2.
lia.
lia.
Qed.
