(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require set.Fset.
Require set.FsetInduction.
Require set.FsetInt.

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  infix_eqeq s1 s2 <->
  ((length s1) = (length s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), infix_eqeq s1 s2 -> (s1 = s2).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> ((length (create len f)) = len).

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < len)%Z -> ((get (create len f) i) = (f i)).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result s i v j) = v)) /\
  (~ (j = i) -> ((result s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result s i v))).

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((length (set s i v)) = (length s)).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (set s i v) i) = v).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> forall (j:Numbers.BinNums.Z),
  ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
  ((get (set s i v) j) = (get s j)).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((length (singleton v)) = 1%Z).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((get (singleton v) 0%Z) = v).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result1 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result1 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result1 x s).

Axiom cons'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((length (cons x s)) = (1%Z + (length s))%Z).

Axiom cons'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((get (cons x s) 0%Z) = x).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z < i)%Z /\ (i <= (length s))%Z ->
  ((get (cons x s) i) = (get s (i - 1%Z)%Z)).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result2 s x i) = x)) /\
  (~ (i = (length s)) -> ((result2 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result2 s x).

Axiom snoc'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((length (snoc s x)) = (1%Z + (length s))%Z).

Axiom snoc'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((get (snoc s x) (length s)) = x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (snoc s x) i) = (get s i)).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
  ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z)).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result3 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result3 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result3 s1 s2 l).

Axiom infix_plpl'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z).

Axiom infix_plpl'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s1))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s1 i)).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z)).

(* Why3 assumption *)
Definition mem {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : Prop :=
  exists i:Numbers.BinNums.Z,
  ((0%Z <= i)%Z /\ (i < (length s))%Z) /\ ((get s i) = x).

Axiom mem_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:seq a) (s2:seq a),
  mem x (infix_plpl s1 s2) <-> mem x s1 \/ mem x s2.

Axiom mem_tail :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), (0%Z < (length s))%Z ->
  mem x s <-> (x = (get s 0%Z)) \/ mem x (mixfix_lb_dtdtrb s 1%Z).

Parameter to_set: forall {a:Type} {a_WT:WhyType a}, seq a -> set.Fset.fset a.

Axiom to_set_empty :
  forall {a:Type} {a_WT:WhyType a},
  ((to_set (empty : seq a)) = (set.Fset.empty : set.Fset.fset a)).

Axiom to_set_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a), (0%Z < (length s))%Z ->
  ((to_set s) = (set.Fset.add (get s 0%Z) (to_set (mixfix_lb_dtdtrb s 1%Z)))).

Axiom to_set_cardinal :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a), ((set.Fset.cardinal (to_set s)) <= (length s))%Z.

Axiom to_set_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (e:a), mem e s <-> set.Fset.mem e (to_set s).

Axiom to_set_snoc :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((to_set (snoc s x)) = (set.Fset.add x (to_set s))).

(* Why3 assumption *)
Definition distinct {a:Type} {a_WT:WhyType a} (s:seq a) : Prop :=
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> (0%Z <= j)%Z /\ (j < (length s))%Z ->
  ~ (i = j) -> ~ ((get s i) = (get s j)).

Axiom to_set_cardinal_distinct :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a), distinct s ->
  ((set.Fset.cardinal (to_set s)) = (length s)).

Parameter sum:
  (Numbers.BinNums.Z -> Numbers.BinNums.Z) -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom sum'def :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  ((b <= a)%Z -> ((sum f a b) = 0%Z)) /\
  (~ (b <= a)%Z ->
   ((sum f a b) = ((sum f a (b - 1%Z)%Z) + (f (b - 1%Z)%Z))%Z)).

Axiom sum_left :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (a < b)%Z -> ((sum f a b) = ((f a) + (sum f (a + 1%Z)%Z b))%Z).

Axiom sum_ext :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> ((f i) = (g i))) ->
  ((sum f a b) = (sum g a b)).

Axiom sum_le :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z ->
   ((f i) <= (g i))%Z) ->
  ((sum f a b) <= (sum g a b))%Z.

Axiom sum_zero :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> ((f i) = 0%Z)) ->
  ((sum f a b) = 0%Z).

Axiom sum_nonneg :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z -> (0%Z <= (f i))%Z) ->
  (0%Z <= (sum f a b))%Z.

Axiom sum_decomp :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  (a <= b)%Z /\ (b <= c)%Z -> ((sum f a c) = ((sum f a b) + (sum f b c))%Z).

Axiom shift_left :
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (g:Numbers.BinNums.Z -> Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((b - a)%Z = (d - c)%Z) ->
  (forall (i:Numbers.BinNums.Z), (a <= i)%Z /\ (i < b)%Z ->
   ((f i) = (g ((c + i)%Z - a)%Z))) ->
  ((sum f a b) = (sum g c d)).

(* Why3 assumption *)
Definition sum1 (s:seq Numbers.BinNums.Z) : Numbers.BinNums.Z :=
  sum (fun (i:Numbers.BinNums.Z) => get s i) 0%Z (length s).

Axiom sum_snoc :
  forall (s:seq Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((sum1 (snoc s x)) = ((sum1 s) + x)%Z).

Axiom sum_tail :
  forall (s:seq Numbers.BinNums.Z), (1%Z <= (length s))%Z ->
  ((sum1 s) = ((get s 0%Z) + (sum1 (mixfix_lb_dtdtrb s 1%Z)))%Z).

Axiom sum_tail_tail :
  forall (s:seq Numbers.BinNums.Z), (2%Z <= (length s))%Z ->
  ((sum1 s) =
   (((get s 0%Z) + (get s 1%Z))%Z + (sum1 (mixfix_lb_dtdtrb s 2%Z)))%Z).

Axiom sum_ge_elt :
  forall (s:seq Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s))%Z ->
   (0%Z <= (get s i))%Z) ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((get s i) <= (sum1 s))%Z.

Axiom sum_one :
  forall (k:Numbers.BinNums.Z),
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z), (0%Z <= k)%Z ->
  (forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < k)%Z -> ((f j) = 1%Z)) ->
  ((sum f 0%Z k) = k).

Axiom sum_one_zero :
  forall (k:Numbers.BinNums.Z),
  forall (f:Numbers.BinNums.Z -> Numbers.BinNums.Z), (0%Z <= k)%Z ->
  (forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < k)%Z ->
   ((f j) = 1%Z) \/ ((f j) = 0%Z)) ->
  ((sum f 0%Z k) <= k)%Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a), (0%Z <= (set.Fset.cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a),
  set.Fset.is_empty s <-> ((set.Fset.cardinal s) = 0%Z).

Axiom cardinal_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set.Fset.fset a),
  ((set.Fset.cardinal (set.Fset.map f s)) <= (set.Fset.cardinal s))%Z.

Axiom add_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (e:a), set.Fset.mem e s ->
  (s = (set.Fset.add e s)).

Axiom add_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set.Fset.fset a) (e:a), ~ set.Fset.mem e s ->
  ((set.Fset.map f (set.Fset.add e s)) =
   (set.Fset.add (f e) (set.Fset.map f s))).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set.Fset.fset a),
  (set.Fset.mem x s ->
   ((set.Fset.cardinal (set.Fset.add x s)) = (set.Fset.cardinal s))) /\
  (~ set.Fset.mem x s ->
   ((set.Fset.cardinal (set.Fset.add x s)) = ((set.Fset.cardinal s) + 1%Z)%Z)).

Axiom interval_def :
  forall (l:Numbers.BinNums.Z) (r:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  set.Fset.mem x (set.FsetInt.interval l r) <-> (l <= x)%Z /\ (x < r)%Z.

Axiom min_elt_def :
  forall (s:set.Fset.fset Numbers.BinNums.Z), ~ set.Fset.is_empty s ->
  set.Fset.mem (set.FsetInt.min_elt s) s /\
  (forall (x:Numbers.BinNums.Z), set.Fset.mem x s ->
   ((set.FsetInt.min_elt s) <= x)%Z).

Axiom cardinal_interval :
  forall (l:Numbers.BinNums.Z) (r:Numbers.BinNums.Z),
  ((l <= r)%Z ->
   ((set.Fset.cardinal (set.FsetInt.interval l r)) = (r - l)%Z)) /\
  (~ (l <= r)%Z -> ((set.Fset.cardinal (set.FsetInt.interval l r)) = 0%Z)).

Axiom filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (p:a -> Init.Datatypes.bool) (x:a),
  set.Fset.mem x (set.Fset.filter s p) <->
  set.Fset.mem x s /\ ((p x) = Init.Datatypes.true).

Axiom min_filter_interval_1 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  (a <=
   (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)))%Z /\
  ((set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)) <
   b)%Z.

Axiom min_filter_interval_2 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  ((p (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p))) =
   Init.Datatypes.true).

Axiom min_filter_interval_3 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  forall (i:Numbers.BinNums.Z),
  (a <= i)%Z /\
  (i <
   (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)))%Z ->
  ~ ((p i) = Init.Datatypes.true).

Axiom feature : Type.
Parameter feature_WhyType : WhyType feature.
Existing Instance feature_WhyType.

(* Why3 assumption *)
Inductive literal :=
  | Pos : feature -> literal
  | Neg : feature -> literal.
Axiom literal_WhyType : WhyType literal.
Existing Instance literal_WhyType.

(* Why3 assumption *)
Definition clause := set.Fset.fset literal.

(* Why3 assumption *)
Definition dnf := seq (set.Fset.fset literal).

(* Why3 assumption *)
Definition dnf_over_L (d:seq (set.Fset.fset literal))
    (l:set.Fset.fset feature) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length d))%Z ->
  set.Fset.subset (get d i)
  (set.Fset.union (set.Fset.map (fun (v:feature) => Pos v) l)
   (set.Fset.map (fun (v:feature) => Neg v) l)).

(* Why3 assumption *)
Definition is_bijection {a:Type} {a_WT:WhyType a} (m:Numbers.BinNums.Z)
    (f:Numbers.BinNums.Z -> a) (s:set.Fset.fset a) : Prop :=
  (0%Z <= m)%Z /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < m)%Z ->
   set.Fset.mem (f i) s) /\
  (forall (x:a), set.Fset.mem x s ->
   (exists i:Numbers.BinNums.Z, ((0%Z <= i)%Z /\ (i < m)%Z) /\ ((f i) = x))) /\
  (forall (i1:Numbers.BinNums.Z) (i2:Numbers.BinNums.Z),
   (0%Z <= i1)%Z /\ (i1 < m)%Z -> (0%Z <= i2)%Z /\ (i2 < m)%Z ->
   ((f i1) = (f i2)) -> (i1 = i2)) /\
  ((set.Fset.cardinal s) = m).

(* Why3 assumption *)
Inductive problem :=
  | problem'mk : seq (set.Fset.fset literal) -> set.Fset.fset feature ->
      Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (Numbers.BinNums.Z -> literal) -> problem.
Axiom problem_WhyType : WhyType problem.
Existing Instance problem_WhyType.

(* Why3 assumption *)
Definition d (v:problem) : seq (set.Fset.fset literal) :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x
  end.

(* Why3 assumption *)
Definition features (v:problem) : set.Fset.fset feature :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x1
  end.

(* Why3 assumption *)
Definition k (v:problem) : Numbers.BinNums.Z :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x2
  end.

(* Why3 assumption *)
Definition n (v:problem) : Numbers.BinNums.Z :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x3
  end.

(* Why3 assumption *)
Definition m (v:problem) : Numbers.BinNums.Z :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x4
  end.

(* Why3 assumption *)
Definition num_to_literal (v:problem) : Numbers.BinNums.Z -> literal :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x5
  end.

(* Why3 assumption *)
Definition problem_valid (input:problem) : Prop :=
  let setLiteral :=
  set.Fset.union (set.Fset.map (fun (v:feature) => Pos v) (features input))
  (set.Fset.map (fun (v:feature) => Neg v) (features input)) in
  (0%Z < (k input))%Z /\
  ((m input) = (set.Fset.cardinal setLiteral)) /\
  (0%Z <= (m input))%Z /\
  ((n input) = (length (d input))) /\
  (0%Z <= (n input))%Z /\
  (forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (n input))%Z ->
   ((set.Fset.cardinal (get (d input) p)) <= (k input))%Z) /\
  dnf_over_L (d input) (features input) /\
  is_bijection (m input) (num_to_literal input) setLiteral.

(* Why3 assumption *)
Definition card_map_pos (s:set.Fset.fset feature) : Prop :=
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Pos v) s)) =
   (set.Fset.cardinal s)).

(* Why3 assumption *)
Definition card_map_neg (s:set.Fset.fset feature) : Prop :=
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Neg v) s)) =
   (set.Fset.cardinal s)).

Axiom Induction :
  (forall (s:set.Fset.fset feature), set.Fset.is_empty s -> card_map_pos s) ->
  (forall (s:set.Fset.fset feature), card_map_pos s ->
   (forall (t:feature), card_map_pos (set.Fset.add t s))) ->
  forall (s:set.Fset.fset feature), card_map_pos s.

Axiom Induction1 :
  (forall (s:set.Fset.fset feature), set.Fset.is_empty s -> card_map_neg s) ->
  (forall (s:set.Fset.fset feature), card_map_neg s ->
   (forall (t:feature), card_map_neg (set.Fset.add t s))) ->
  forall (s:set.Fset.fset feature), card_map_neg s.

Axiom not_mem_map_pos :
  forall (s:set.Fset.fset feature) (l:feature), ~ set.Fset.mem l s ->
  ~ set.Fset.mem (Pos l) (set.Fset.map (fun (v:feature) => Pos v) s).

Axiom not_mem_map_neg :
  forall (s:set.Fset.fset feature) (l:feature), ~ set.Fset.mem l s ->
  ~ set.Fset.mem (Neg l) (set.Fset.map (fun (v:feature) => Neg v) s).

Axiom card_map_pos1 :
  forall (s:set.Fset.fset feature),
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Pos v) s)) =
   (set.Fset.cardinal s)).

Axiom card_map_neg1 :
  forall (s:set.Fset.fset feature),
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Neg v) s)) =
   (set.Fset.cardinal s)).

Axiom link_m_feature :
  forall (pb:problem), problem_valid pb ->
  ((m pb) = (2%Z * (set.Fset.cardinal (features pb)))%Z).

Axiom literal_to_num :
  forall (pb:problem), forall (l:literal), forall (p:Numbers.BinNums.Z),
  problem_valid pb -> (0%Z <= p)%Z /\ (p < (length (d pb)))%Z ->
  set.Fset.mem l (get (d pb) p) ->
  exists il:Numbers.BinNums.Z,
  ((0%Z <= il)%Z /\ (il < (m pb))%Z) /\ ((num_to_literal pb il) = l).

(* Why3 assumption *)
Inductive nested_witness :=
  | nested_witness'mk : seq (seq literal) -> seq (seq Numbers.BinNums.Z) ->
      nested_witness.
Axiom nested_witness_WhyType : WhyType nested_witness.
Existing Instance nested_witness_WhyType.

(* Why3 assumption *)
Definition lm (v:nested_witness) : seq (seq literal) :=
  match v with
  | nested_witness'mk x x1 => x
  end.

(* Why3 assumption *)
Definition rpi (v:nested_witness) : seq (seq Numbers.BinNums.Z) :=
  match v with
  | nested_witness'mk x x1 => x1
  end.

(* Why3 assumption *)
Definition nested_witness_valid (k':Numbers.BinNums.Z) (input:problem)
    (nw:nested_witness) : Prop :=
  ((length (lm nw)) = k') /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length (lm nw)))%Z ->
   ((length (get (lm nw) i)) = (k input))) /\
  ((length (rpi nw)) = (n input)) /\
  (forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (n input))%Z ->
   ((length (get (rpi nw) p)) = k')) /\
  (forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
   (0%Z <= i)%Z /\ (i < (length (lm nw)))%Z ->
   (0%Z <= j)%Z /\ (j < (k input))%Z ->
   set.Fset.mem (get (get (lm nw) i) j)
   (set.Fset.union (set.Fset.map (fun (v:feature) => Pos v) (features input))
    (set.Fset.map (fun (v:feature) => Neg v) (features input)))) /\
  (forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (n input))%Z ->
   (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < k')%Z ->
    (0%Z <= (get (get (rpi nw) p) i))%Z)).

(* Why3 assumption *)
Definition is_nested_witness (k':Numbers.BinNums.Z) (input:problem)
    (nw:nested_witness) : Prop :=
  nested_witness_valid k' input nw /\
  (forall (p:Numbers.BinNums.Z), forall (i:Numbers.BinNums.Z),
   (0%Z <= p)%Z /\ (p < (length (d input)))%Z ->
   (0%Z <= i)%Z /\ (i < k')%Z -> ((get (get (rpi nw) p) i) <= (k input))%Z) /\
  (forall (p:Numbers.BinNums.Z),
   (0%Z <= p)%Z /\ (p < (length (d input)))%Z ->
   (forall (l:literal),
    set.Fset.mem l (get (d input) p) <->
    (exists i:Numbers.BinNums.Z, exists j:Numbers.BinNums.Z,
     ((0%Z <= i)%Z /\ (i < k')%Z) /\
     ((0%Z <= j)%Z /\ (j < (get (get (rpi nw) p) i))%Z) /\
     (l = (get (get (lm nw) i) j))))).

Axiom lmIndp :
  forall (k':Numbers.BinNums.Z), forall (input:problem),
  forall (nw:nested_witness), problem_valid input ->
  is_nested_witness k' input nw -> forall (p:Numbers.BinNums.Z),
  (0%Z <= p)%Z /\ (p < (length (d input)))%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < k')%Z -> forall (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j < (get (get (rpi nw) p) i))%Z ->
  set.Fset.mem (get (get (lm nw) i) j) (get (d input) p).

Axiom dpInlm :
  forall (k':Numbers.BinNums.Z), forall (input:problem),
  forall (nw:nested_witness), problem_valid input ->
  is_nested_witness k' input nw -> forall (p:Numbers.BinNums.Z),
  forall (l:literal), (0%Z <= p)%Z /\ (p < (length (d input)))%Z ->
  set.Fset.mem l (get (d input) p) ->
  exists i:Numbers.BinNums.Z,
  exists j:Numbers.BinNums.Z,
  ((0%Z <= i)%Z /\ (i < k')%Z) /\
  ((0%Z <= j)%Z /\ (j < (get (get (rpi nw) p) i))%Z) /\
  (l = (get (get (lm nw) i) j)).

(* Why3 assumption *)
Definition is_nested_k_kp_dnf (k':Numbers.BinNums.Z) (pb:problem) : Prop :=
  problem_valid pb /\ (exists nw:nested_witness, is_nested_witness k' pb nw).

(* Why3 assumption *)
Inductive sat_witness :=
  | sat_witness'mk : seq (seq (seq Init.Datatypes.bool)) ->
      seq (seq (seq Init.Datatypes.bool)) ->
      seq (seq (seq (seq Init.Datatypes.bool))) -> sat_witness.
Axiom sat_witness_WhyType : WhyType sat_witness.
Existing Instance sat_witness_WhyType.

(* Why3 assumption *)
Definition x (v:sat_witness) : seq (seq (seq Init.Datatypes.bool)) :=
  match v with
  | sat_witness'mk x1 x2 x3 => x1
  end.

(* Why3 assumption *)
Definition r (v:sat_witness) : seq (seq (seq Init.Datatypes.bool)) :=
  match v with
  | sat_witness'mk x1 x2 x3 => x2
  end.

(* Why3 assumption *)
Definition t (v:sat_witness) : seq (seq (seq (seq Init.Datatypes.bool))) :=
  match v with
  | sat_witness'mk x1 x2 x3 => x3
  end.

(* Why3 assumption *)
Definition sat_witness_valid (k':Numbers.BinNums.Z) (input:problem)
    (sw:sat_witness) : Prop :=
  ((length (x sw)) = k') /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < k')%Z ->
   ((length (get (x sw) i)) = (k input))) /\
  (forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
   (0%Z <= i)%Z /\ (i < k')%Z -> (0%Z <= j)%Z /\ (j < k')%Z ->
   ((length (get (get (x sw) i) j)) = (m input))) /\
  ((length (r sw)) = (n input)) /\
  (forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (n input))%Z ->
   ((length (get (r sw) p)) = k')) /\
  (forall (p:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
   (0%Z <= p)%Z /\ (p < (n input))%Z -> (0%Z <= i)%Z /\ (i < k')%Z ->
   ((length (get (get (r sw) p) i)) = (k input))) /\
  ((length (t sw)) = (n input)) /\
  (forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (n input))%Z ->
   ((length (get (t sw) p)) = k')) /\
  (forall (p:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
   (0%Z <= p)%Z /\ (p < (n input))%Z -> (0%Z <= i)%Z /\ (i < k')%Z ->
   ((length (get (get (t sw) p) i)) = (k input))) /\
  (forall (p:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
   (0%Z <= p)%Z /\ (p < (n input))%Z -> (0%Z <= i)%Z /\ (i < k')%Z ->
   (0%Z <= j)%Z /\ (j < (k input))%Z ->
   ((length (get (get (get (t sw) p) i) j)) = (m input))).

(* Why3 assumption *)
Definition atLeastOneElement (k':Numbers.BinNums.Z) (input:problem)
    (sw:sat_witness) : Prop :=
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < k')%Z -> (0%Z <= j)%Z /\ (j < (k input))%Z ->
  exists l:Numbers.BinNums.Z,
  ((0%Z <= l)%Z /\ (l < (m input))%Z) /\
  ((get (get (get (x sw) i) j) l) = Init.Datatypes.true).

(* Why3 assumption *)
Definition atMostOneElement (k':Numbers.BinNums.Z) (input:problem)
    (sw:sat_witness) : Prop :=
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < k')%Z -> (0%Z <= j)%Z /\ (j < (k input))%Z ->
  (0%Z <= a)%Z /\ (a < (m input))%Z -> (0%Z <= b)%Z /\ (b < (m input))%Z ->
  ~ (a = b) ->
  ~ ((get (get (get (x sw) i) j) a) = Init.Datatypes.true) \/
  ~ ((get (get (get (x sw) i) j) b) = Init.Datatypes.true).

(* Why3 assumption *)
Definition nested (k':Numbers.BinNums.Z) (input:problem) (sw:sat_witness) :
    Prop :=
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (p:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < k')%Z ->
  (0%Z <= j)%Z /\ (j < ((k input) - 1%Z)%Z)%Z ->
  (0%Z <= p)%Z /\ (p < (n input))%Z ->
  ~ ((get (get (get (r sw) p) i) (j + 1%Z)%Z) = Init.Datatypes.true) \/
  ((get (get (get (r sw) p) i) j) = Init.Datatypes.true).

(* Why3 assumption *)
Definition linkTXR (k':Numbers.BinNums.Z) (input:problem) (sw:sat_witness) :
    Prop :=
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (p:Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < k')%Z -> (0%Z <= j)%Z /\ (j < (k input))%Z ->
  (0%Z <= p)%Z /\ (p < (n input))%Z -> (0%Z <= l)%Z /\ (l < (m input))%Z ->
  (~ ((get (get (get (get (t sw) p) i) j) l) = Init.Datatypes.true) \/
   ((get (get (get (x sw) i) j) l) = Init.Datatypes.true)) /\
  (~ ((get (get (get (get (t sw) p) i) j) l) = Init.Datatypes.true) \/
   ((get (get (get (r sw) p) i) j) = Init.Datatypes.true)) /\
  (~ ((get (get (get (x sw) i) j) l) = Init.Datatypes.true) \/
   ~ ((get (get (get (r sw) p) i) j) = Init.Datatypes.true) \/
   ((get (get (get (get (t sw) p) i) j) l) = Init.Datatypes.true)).

(* Why3 assumption *)
Definition buildTMem (k':Numbers.BinNums.Z) (input:problem)
    (sw:sat_witness) : Prop :=
  forall (l:Numbers.BinNums.Z) (p:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (l < (m input))%Z -> (0%Z <= p)%Z /\ (p < (n input))%Z ->
  set.Fset.mem (num_to_literal input l) (get (d input) p) ->
  exists i:Numbers.BinNums.Z, exists j:Numbers.BinNums.Z,
  ((0%Z <= i)%Z /\ (i < k')%Z) /\
  ((0%Z <= j)%Z /\ (j < (k input))%Z) /\
  ((get (get (get (get (t sw) p) i) j) l) = Init.Datatypes.true).

(* Why3 assumption *)
Definition buildTNotMem (k':Numbers.BinNums.Z) (input:problem)
    (sw:sat_witness) : Prop :=
  forall (l:Numbers.BinNums.Z) (p:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (l < (m input))%Z -> (0%Z <= p)%Z /\ (p < (n input))%Z ->
  ~ set.Fset.mem (num_to_literal input l) (get (d input) p) ->
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < k')%Z -> (0%Z <= j)%Z /\ (j < (k input))%Z ->
  ~ ((get (get (get (get (t sw) p) i) j) l) = Init.Datatypes.true).

(* Why3 assumption *)
Definition is_sat_witness (k':Numbers.BinNums.Z) (input:problem)
    (sw:sat_witness) : Prop :=
  sat_witness_valid k' input sw /\
  atLeastOneElement k' input sw /\
  atMostOneElement k' input sw /\
  nested k' input sw /\
  linkTXR k' input sw /\ buildTMem k' input sw /\ buildTNotMem k' input sw.

(* Why3 assumption *)
Definition is_satisfiable (k':Numbers.BinNums.Z) (pb:problem) : Prop :=
  problem_valid pb /\ (exists sw:sat_witness, is_sat_witness k' pb sw).

Parameter fc:
  sat_witness -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom fc'def :
  forall (sw:sat_witness) (p:Numbers.BinNums.Z) (i:Numbers.BinNums.Z)
    (j:Numbers.BinNums.Z),
  ((fc sw p i j) = Init.Datatypes.true) <->
  ~ ((get (get (get (r sw) p) i) j) = Init.Datatypes.true).

Axiom firstNot :
  forall (k':Numbers.BinNums.Z), forall (pb:problem),
  forall (sw:sat_witness), problem_valid pb -> nested k' pb sw ->
  forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (length (d pb)))%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < k')%Z ->
  (exists j:Numbers.BinNums.Z,
   ((0%Z <= j)%Z /\ (j < (k pb))%Z) /\
   ~ ((get (get (get (r sw) p) i) j) = Init.Datatypes.true)) ->
  let b :=
  set.FsetInt.min_elt
  (set.Fset.filter (set.FsetInt.interval 0%Z (k pb)) (fc sw p i)) in
  ((0%Z <= b)%Z /\ (b < (k pb))%Z) /\
  ~ ((get (get (get (r sw) p) i) b) = Init.Datatypes.true) /\
  (forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < b)%Z ->
   ((get (get (get (r sw) p) i) j) = Init.Datatypes.true)).

Axiom notThenNotPlus1 :
  forall (k':Numbers.BinNums.Z), forall (pb:problem),
  forall (sw:sat_witness), problem_valid pb -> nested k' pb sw ->
  forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (length (d pb)))%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < k')%Z ->
  forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < ((k pb) - 1%Z)%Z)%Z ->
  ~ ((get (get (get (r sw) p) i) j) = Init.Datatypes.true) ->
  ~ ((get (get (get (r sw) p) i) (j + 1%Z)%Z) = Init.Datatypes.true).


Require Import Lia.



(* Why3 goal *)
Theorem notThenNot :
  forall (k':Numbers.BinNums.Z), forall (pb:problem),
  forall (sw:sat_witness), problem_valid pb -> nested k' pb sw ->
  forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (length (d pb)))%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < k')%Z ->
  forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < (k pb))%Z ->
  ~ ((get (get (get (r sw) p) i) j) = Init.Datatypes.true) ->
  forall (l:Numbers.BinNums.Z), (j <= l)%Z /\ (l < (k pb))%Z ->
  ~ ((get (get (get (r sw) p) i) l) = Init.Datatypes.true).
(* Why3 intros k' pb sw h1 h2 p (h3,h4) i (h5,h6) j (h7,h8) h9 l (h10,h11). *)
Proof.
intros k' pb sw h1 h2 p cp i ci j cj h9 k1 ck1.
  (* Induction on k1 - j *)
  remember (Z.to_nat (k1 - j)) as m eqn:Heqm.

  (* Induction on m *)
  revert k1 ck1 Heqm.
  induction m.
  - (*  m = 0 so k1 = j *)
    intros k1 ck1 Heqm.
    assert (dk1 : (k1=j)%Z) by lia.
    rewrite dk1.
    exact h9.
  - (* inductif case : m+1 >= 0 *)
    intros k1 ck1 Heqm.
    assert (((k1=j) \/ (k1 > j))%Z) by lia.
    destruct H.
    (* k1=j*)
    rewrite H.
    exact h9.
    (* (k1 > j)%Z *)
    set (k0 := (k1 - 1)%Z).
    assert (Hk0: (j <= k0 < (k pb) -1)%Z) by lia.
    (* Axiom on j := k0 *)
    pose proof (notThenNotPlus1 k' pb sw h1 h2 p cp i ci k0) as Hax.
    assert (Hk0' : (0 <= k0 < (k pb) - 1)%Z).
    {
      split.
      - (*  0 <= k0 *) 
        assert (0 <= j)%Z by lia. lia.
      - (*  k0 < k pb - 1 *)
        lia.
    }
    specialize (Hax Hk0').
    assert ((k0 +1 = k1)%Z) by lia.
    rewrite <- H0.
    apply Hax.
    (* Induction hypothesis on k0 *)
    apply IHm.
    + lia.
    + lia.
Qed.
