(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require set.Fset.
Require set.FsetInduction.
Require set.FsetInt.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a), (0%Z <= (set.Fset.cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a),
  set.Fset.is_empty s <-> ((set.Fset.cardinal s) = 0%Z).

Axiom cardinal_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set.Fset.fset a),
  ((set.Fset.cardinal (set.Fset.map f s)) <= (set.Fset.cardinal s))%Z.

Axiom add_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (e:a), set.Fset.mem e s ->
  (s = (set.Fset.add e s)).

Axiom add_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set.Fset.fset a) (e:a), ~ set.Fset.mem e s ->
  ((set.Fset.map f (set.Fset.add e s)) =
   (set.Fset.add (f e) (set.Fset.map f s))).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set.Fset.fset a),
  (set.Fset.mem x s ->
   ((set.Fset.cardinal (set.Fset.add x s)) = (set.Fset.cardinal s))) /\
  (~ set.Fset.mem x s ->
   ((set.Fset.cardinal (set.Fset.add x s)) = ((set.Fset.cardinal s) + 1%Z)%Z)).

Axiom interval_def :
  forall (l:Numbers.BinNums.Z) (r:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  set.Fset.mem x (set.FsetInt.interval l r) <-> (l <= x)%Z /\ (x < r)%Z.

Axiom min_elt_def :
  forall (s:set.Fset.fset Numbers.BinNums.Z), ~ set.Fset.is_empty s ->
  set.Fset.mem (set.FsetInt.min_elt s) s /\
  (forall (x:Numbers.BinNums.Z), set.Fset.mem x s ->
   ((set.FsetInt.min_elt s) <= x)%Z).

Axiom cardinal_interval :
  forall (l:Numbers.BinNums.Z) (r:Numbers.BinNums.Z),
  ((l <= r)%Z ->
   ((set.Fset.cardinal (set.FsetInt.interval l r)) = (r - l)%Z)) /\
  (~ (l <= r)%Z -> ((set.Fset.cardinal (set.FsetInt.interval l r)) = 0%Z)).

Axiom filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset a) (p:a -> Init.Datatypes.bool) (x:a),
  set.Fset.mem x (set.Fset.filter s p) <->
  set.Fset.mem x s /\ ((p x) = Init.Datatypes.true).

Axiom min_filter_interval_1 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  (a <=
   (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)))%Z /\
  ((set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)) <
   b)%Z.

Axiom min_filter_interval_2 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  ((p (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p))) =
   Init.Datatypes.true).

Axiom min_filter_interval_3 :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z)
    (p:Numbers.BinNums.Z -> Init.Datatypes.bool),
  (exists i:Numbers.BinNums.Z,
   ((a <= i)%Z /\ (i < b)%Z) /\ ((p i) = Init.Datatypes.true)) ->
  forall (i:Numbers.BinNums.Z),
  (a <= i)%Z /\
  (i <
   (set.FsetInt.min_elt (set.Fset.filter (set.FsetInt.interval a b) p)))%Z ->
  ~ ((p i) = Init.Datatypes.true).

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  infix_eqeq s1 s2 <->
  ((length s1) = (length s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), infix_eqeq s1 s2 -> (s1 = s2).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> ((length (create len f)) = len).

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < len)%Z -> ((get (create len f) i) = (f i)).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result s i v j) = v)) /\
  (~ (j = i) -> ((result s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result s i v))).

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((length (set s i v)) = (length s)).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (set s i v) i) = v).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> forall (j:Numbers.BinNums.Z),
  ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
  ((get (set s i v) j) = (get s j)).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((length (singleton v)) = 1%Z).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((get (singleton v) 0%Z) = v).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result1 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result1 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result1 x s).

Axiom cons'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((length (cons x s)) = (1%Z + (length s))%Z).

Axiom cons'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((get (cons x s) 0%Z) = x).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z < i)%Z /\ (i <= (length s))%Z ->
  ((get (cons x s) i) = (get s (i - 1%Z)%Z)).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result2 s x i) = x)) /\
  (~ (i = (length s)) -> ((result2 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result2 s x).

Axiom snoc'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((length (snoc s x)) = (1%Z + (length s))%Z).

Axiom snoc'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((get (snoc s x) (length s)) = x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (snoc s x) i) = (get s i)).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
  ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z)).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result3 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result3 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result3 s1 s2 l).

Axiom infix_plpl'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z).

Axiom infix_plpl'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s1))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s1 i)).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z)).

Axiom feature : Type.
Parameter feature_WhyType : WhyType feature.
Existing Instance feature_WhyType.

(* Why3 assumption *)
Inductive literal :=
  | Pos : feature -> literal
  | Neg : feature -> literal.
Axiom literal_WhyType : WhyType literal.
Existing Instance literal_WhyType.

(* Why3 assumption *)
Definition clause := set.Fset.fset literal.

(* Why3 assumption *)
Definition dnf := seq (set.Fset.fset literal).

(* Why3 assumption *)
Definition dnf_over_L (d:seq (set.Fset.fset literal))
    (l:set.Fset.fset feature) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length d))%Z ->
  set.Fset.subset (get d i)
  (set.Fset.union (set.Fset.map (fun (v:feature) => Pos v) l)
   (set.Fset.map (fun (v:feature) => Neg v) l)).

(* Why3 assumption *)
Definition is_bijection {a:Type} {a_WT:WhyType a} (m:Numbers.BinNums.Z)
    (f:Numbers.BinNums.Z -> a) (s:set.Fset.fset a) : Prop :=
  (0%Z <= m)%Z /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < m)%Z ->
   set.Fset.mem (f i) s) /\
  (forall (x:a), set.Fset.mem x s ->
   (exists i:Numbers.BinNums.Z, ((0%Z <= i)%Z /\ (i < m)%Z) /\ ((f i) = x))) /\
  (forall (i1:Numbers.BinNums.Z) (i2:Numbers.BinNums.Z),
   (0%Z <= i1)%Z /\ (i1 < m)%Z -> (0%Z <= i2)%Z /\ (i2 < m)%Z ->
   ((f i1) = (f i2)) -> (i1 = i2)) /\
  ((set.Fset.cardinal s) = m).

(* Why3 assumption *)
Inductive problem :=
  | problem'mk : seq (set.Fset.fset literal) -> set.Fset.fset feature ->
      Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      (Numbers.BinNums.Z -> literal) -> problem.
Axiom problem_WhyType : WhyType problem.
Existing Instance problem_WhyType.

(* Why3 assumption *)
Definition d (v:problem) : seq (set.Fset.fset literal) :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x
  end.

(* Why3 assumption *)
Definition features (v:problem) : set.Fset.fset feature :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x1
  end.

(* Why3 assumption *)
Definition k (v:problem) : Numbers.BinNums.Z :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x2
  end.

(* Why3 assumption *)
Definition n (v:problem) : Numbers.BinNums.Z :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x3
  end.

(* Why3 assumption *)
Definition m (v:problem) : Numbers.BinNums.Z :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x4
  end.

(* Why3 assumption *)
Definition num_to_literal (v:problem) : Numbers.BinNums.Z -> literal :=
  match v with
  | problem'mk x x1 x2 x3 x4 x5 => x5
  end.

(* Why3 assumption *)
Definition problem_valid (input:problem) : Prop :=
  let setLiteral :=
  set.Fset.union (set.Fset.map (fun (v:feature) => Pos v) (features input))
  (set.Fset.map (fun (v:feature) => Neg v) (features input)) in
  (0%Z < (k input))%Z /\
  ((m input) = (set.Fset.cardinal setLiteral)) /\
  (0%Z <= (m input))%Z /\
  ((n input) = (length (d input))) /\
  (0%Z <= (n input))%Z /\
  (forall (p:Numbers.BinNums.Z), (0%Z <= p)%Z /\ (p < (n input))%Z ->
   ((set.Fset.cardinal (get (d input) p)) <= (k input))%Z) /\
  dnf_over_L (d input) (features input) /\
  is_bijection (m input) (num_to_literal input) setLiteral.

(* Why3 assumption *)
Definition card_map_pos (s:set.Fset.fset feature) : Prop :=
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Pos v) s)) =
   (set.Fset.cardinal s)).

(* Why3 assumption *)
Definition card_map_neg (s:set.Fset.fset feature) : Prop :=
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Neg v) s)) =
   (set.Fset.cardinal s)).

Axiom Induction :
  (forall (s:set.Fset.fset feature), set.Fset.is_empty s -> card_map_pos s) ->
  (forall (s:set.Fset.fset feature), card_map_pos s ->
   (forall (t:feature), card_map_pos (set.Fset.add t s))) ->
  forall (s:set.Fset.fset feature), card_map_pos s.

Axiom Induction1 :
  (forall (s:set.Fset.fset feature), set.Fset.is_empty s -> card_map_neg s) ->
  (forall (s:set.Fset.fset feature), card_map_neg s ->
   (forall (t:feature), card_map_neg (set.Fset.add t s))) ->
  forall (s:set.Fset.fset feature), card_map_neg s.

Axiom not_mem_map_pos :
  forall (s:set.Fset.fset feature) (l:feature), ~ set.Fset.mem l s ->
  ~ set.Fset.mem (Pos l) (set.Fset.map (fun (v:feature) => Pos v) s).

Axiom not_mem_map_neg :
  forall (s:set.Fset.fset feature) (l:feature), ~ set.Fset.mem l s ->
  ~ set.Fset.mem (Neg l) (set.Fset.map (fun (v:feature) => Neg v) s).

Axiom card_map_pos1 :
  forall (s:set.Fset.fset feature),
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Pos v) s)) =
   (set.Fset.cardinal s)).


Require Import Lia.

(* Why3 goal *)
Theorem card_map_neg1 :
  forall (s:set.Fset.fset feature),
  ((set.Fset.cardinal (set.Fset.map (fun (v:feature) => Neg v) s)) =
   (set.Fset.cardinal s)).
(* Why3 intros s. *)
Proof.
intros s.
apply Induction1.
(* empty case *)
intros.
unfold card_map_neg.
generalize (cardinal_empty s0).
intro.
destruct H0.
generalize (H0 H).
intro r1.
rewrite r1.
generalize (cardinal_map (fun v : feature => Neg v) s0).
generalize (cardinal_nonneg (Fset.map (fun v : feature => Neg v) s0)).
lia.
(* general case *)
intros.
cut (set.Fset.mem t s0 \/ ~(set.Fset.mem t s0)).
(* mem t s0 *)
intro c.
destruct c.
generalize (add_mem s0 t H0).
intro r.
rewrite <- r.
apply H.
(* ~ mem t s0 *)
unfold card_map_neg.
generalize (add_map (fun v : feature => Neg v) s0 t H0).
intro r.
rewrite r.
unfold card_map_neg in H.
generalize (cardinal_add t s0).
intro.
destruct H1.
generalize (H2 H0).
intro r1.
rewrite r1.
generalize (cardinal_add (Neg t) (Fset.map (fun v : feature => Neg v) s0)).
intro.
destruct H3.
cut (~ Fset.mem (Neg t) (Fset.map (fun v : feature => Neg v) s0)).
intro.
generalize (H4 H5).
lia.
(* ~ Fset.mem (Pos t) (Fset.map (fun v : feature => Pos v) s0) *)
apply (not_mem_map_neg s0 t H0).
tauto.
Qed.
